import{_ as a,c as n,b as i,o as e}from"./app-BrZHaSrv.js";const l={};function p(t,s){return e(),n("div",null,s[0]||(s[0]=[i(`<p>​ 双指针法是一种特别巧妙的方法，通常是设置一个快指针和一个慢指针，在很多情景中能把使用两层 for 循环才能解决的问题只使用一层 for 循环就能解决掉。（ 整理自《代码随想录》，题目来源是力扣。）</p><h3 id="一、数组" tabindex="-1"><a class="header-anchor" href="#一、数组"><span>一、数组</span></a></h3><h4 id="_1、移除数组中元素-题号-27" tabindex="-1"><a class="header-anchor" href="#_1、移除数组中元素-题号-27"><span>1、移除数组中元素（题号：27）</span></a></h4><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520104358926.png" alt="image-20250520104358926"></p><h5 id="暴力解法" tabindex="-1"><a class="header-anchor" href="#暴力解法"><span>暴力解法：</span></a></h5><p>​ 使用两层 for 循环，第一个 for 循环遍历数组元素，第二个 for 循环更新数组元素，过程如下图所示。</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520104717494.png" alt="image-20250520104717494"></p><h6 id="暴力解法的-java-代码如下" tabindex="-1"><a class="header-anchor" href="#暴力解法的-java-代码如下"><span>暴力解法的 java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public int removeElement(int[] nums, int val) {</span></span>
<span class="line"><span>        int size = nums.length;</span></span>
<span class="line"><span>        for (int i = 0; i &lt; size; i++) {</span></span>
<span class="line"><span>            if (nums[i] == val) {</span></span>
<span class="line"><span>                for (int j = i + 1; j &lt; size; j++) {</span></span>
<span class="line"><span>                    nums[j - 1] = nums[j];</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>                 i--; //因为此时i下标的元素被替换掉了，下一轮循环i会自增1，所以先减1，确保下一轮循环还从这个下标开始</span></span>
<span class="line"><span>                 size--; //删除掉一个元素，所以长度减1</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return size;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>时间复杂度：o(n<sup>2</sup>)</p></li><li><p>空间复杂度：o(1)</p></li></ul><h5 id="双指针法" tabindex="-1"><a class="header-anchor" href="#双指针法"><span>双指针法</span></a></h5><p>​ 使用两个快慢指针，快指针和慢指针下标均从 0 开始。快指针会一直往前移动，如果快指针指向的元素不是目标元素，则慢指针和快指针同步向前移动，并将快指针的指向的值赋给慢指针，当快指针指向的值是目标值时，快指针向前移动，慢指针不向前移动也不赋值。</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520111148888.png" alt="image-20250520111148888"></p><h6 id="java-代码如下" tabindex="-1"><a class="header-anchor" href="#java-代码如下"><span>java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public int removeElement(int[] nums, int val) {</span></span>
<span class="line"><span>        int n = nums.length;</span></span>
<span class="line"><span>        int slowIndex = 0;</span></span>
<span class="line"><span>        for (int fastIndex = 0; fastIndex &lt; n; fastIndex++) {</span></span>
<span class="line"><span>            if (nums[fastIndex] != val) {</span></span>
<span class="line"><span>                nums[slowIndex] = nums[fastIndex];</span></span>
<span class="line"><span>                slowIndex++;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return slowIndex;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>时间复杂度：o(n)</li><li>空间复杂度：o(1)</li></ul><h4 id="_2、长度最小的子数组-题号-209" tabindex="-1"><a class="header-anchor" href="#_2、长度最小的子数组-题号-209"><span>2、长度最小的子数组(题号：209)</span></a></h4><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520150743651.png" alt="image-20250520150743651"></p><h5 id="暴力解法-1" tabindex="-1"><a class="header-anchor" href="#暴力解法-1"><span>暴力解法：</span></a></h5><p>​ 使用两个 for 循环，不断地寻找符合条件的子数组。外层 for 循环是子数组的开头，内层 for 循环是子数组的结尾。</p><h6 id="java-代码如下-1" tabindex="-1"><a class="header-anchor" href="#java-代码如下-1"><span>java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public int minSubArrayLen(int target, int[] nums) {</span></span>
<span class="line"><span>        int n = nums.length;</span></span>
<span class="line"><span>        if (n == 0) {   //如果所给数组的长度为0，直接返回</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        int length = Integer.MAX_VALUE;  //将int类型的最大值初始化给length</span></span>
<span class="line"><span>        for (int i = 0; i &lt; n; i++) {</span></span>
<span class="line"><span>            int sum = 0;</span></span>
<span class="line"><span>            for (int j = i; j &lt; n; j++) {</span></span>
<span class="line"><span>                sum += nums[j];</span></span>
<span class="line"><span>                if (sum &gt;= target) {</span></span>
<span class="line"><span>                    length = Math.min(length, j - i + 1);</span></span>
<span class="line"><span>                    break;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return length == Integer.MAX_VALUE ? 0 : length;  //如果循环结束length的值还是Integer.MAX_VALUE说明不存在															  这样的子数组，返回0，如果不是就返回length的值</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>时间复杂度：o(n<sup>2</sup>)</p></li><li><p>空间复杂度：o(1)</p></li></ul><h5 id="双指针-滑动窗口-法" tabindex="-1"><a class="header-anchor" href="#双指针-滑动窗口-法"><span>双指针（滑动窗口）法：</span></a></h5><p>​ 使用两个快慢指针，初始都为 0。慢指针记为 slow，表示子数组的开头，快指针记为 fast，表示子数组的结尾，快慢指针之间的区域（包含两个指针）可以看成是一个滑动窗口。将滑动窗口中所有元素值的总和简称为窗口值，初始是数组第一个元素的值。</p><p>​ 设置一个变量 length，初始为 int 型数据的最大值，用来记录子数组的长度。</p><p>​ 首先快指针开始向前移动，每移动一步都会有新的元素加进来，此时要更新窗口值，并判断窗口值是否大于等于目标值。如果大于等于目标值，则比较此时的<mark>length 值</mark>和==窗口也就是子数组的长度（fast - slow + 1）==的大小，将最小值赋值给 length。之后将慢指针向前移动一步，并更新窗口值（减去原来慢指针的值）再进行判断。如果窗口值小于目标值，则将快指针再向前移动。</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520152352371.png" alt="image-20250520152352371"></p><p>需要注意的是：</p><ul><li>窗口内的元素：保持窗口内数值总和大于或等于目标值的长度最小的连续子数组。</li><li>移动窗口的起始位置：如果当前窗口的值大于目标值，则将窗口向前移动（也就是窗口该缩小了）。</li><li>移动窗口的结束位置：窗口的结束位置就是外层循环遍历数组的指针。</li></ul><p>这个方法的巧妙之处就在于根据当前子数组和的大小，不断调节子数组的起始位置，快慢指针均不回退。</p><h6 id="java-代码如下-2" tabindex="-1"><a class="header-anchor" href="#java-代码如下-2"><span>java 代码如下</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public int minSubArrayLen(int target, int[] nums) {</span></span>
<span class="line"><span>        int n = nums.length;</span></span>
<span class="line"><span>        if (n == 0) {</span></span>
<span class="line"><span>            return 0;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        int length = Integer.MAX_VALUE;</span></span>
<span class="line"><span>        int slow = 0;</span></span>
<span class="line"><span>        int sum = 0;</span></span>
<span class="line"><span>        for (int fast = 0; fast &lt; n; fast++) {</span></span>
<span class="line"><span>            sum += nums[fast];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            ************//思考为什么这里用的是循环而不是if判断呢？**********8</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            while (sum &gt;= target) {</span></span>
<span class="line"><span>                length = Math.min(length, fast - slow + 1);</span></span>
<span class="line"><span>                sum -= nums[slow];</span></span>
<span class="line"><span>                slow++;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return length == Integer.MAX_VALUE ? 0 : length;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>时间复杂度：o(n)</li><li>空间复杂度：o(1)</li></ul><h3 id="二、链表" tabindex="-1"><a class="header-anchor" href="#二、链表"><span>二、链表</span></a></h3><h4 id="_1、反转链表-题号-206" tabindex="-1"><a class="header-anchor" href="#_1、反转链表-题号-206"><span>1、反转链表（题号：206）</span></a></h4><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520161346990.png" alt="image-20250520161346990"></p><p>​ 首先定义一个 cur 指针，指向头节点，再定义一个 pre 指针，初始化为 NULL，使用 temp 指针保存 cur-&gt;next 节点。保存这个节点的原因是因为接下来要改变 cur-&gt;next 的指向，将 cur-&gt;next 指向 pre。</p><p>​ 反转过程：</p><ul><li>将 temp 指针指向 cur-&gt;next 节点</li><li>将 cur-&gt;next 指向 pre 节点</li><li>将 pre 指针指向 cur 节点</li><li>将 cur 指向 temp 节点</li></ul><p>​ 翻转过程如下：</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520162638994.png" alt="image-20250520162638994"></p><p>​ 然后循环执行以上的逻辑，继续移动 pre 和 cur 指针。</p><p>​ 最后 cur 指针指向了 NULL。循环结束，链表也反转完毕。此时我们返回 pre 指针即可，pre 指针就指向了新的头节点，如图所示：</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520163821571.png" alt="image-20250520163821571"></p><h6 id="java-代码如下-3" tabindex="-1"><a class="header-anchor" href="#java-代码如下-3"><span>java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>//链表的数据结构如下：</span></span>
<span class="line"><span>public class ListNode {</span></span>
<span class="line"><span>     int val;</span></span>
<span class="line"><span>     ListNode next;</span></span>
<span class="line"><span>     ListNode() {}</span></span>
<span class="line"><span>     ListNode(int val) { this.val = val; }</span></span>
<span class="line"><span>     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span> class Solution {</span></span>
<span class="line"><span>    public ListNode reverseList(ListNode head) {</span></span>
<span class="line"><span>        ListNode cur = head;</span></span>
<span class="line"><span>        ListNode pre = null;</span></span>
<span class="line"><span>        ListNode temp = new ListNode();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (cur != null) {</span></span>
<span class="line"><span>            temp = cur.next;</span></span>
<span class="line"><span>            cur.next = pre;</span></span>
<span class="line"><span>            pre = cur;</span></span>
<span class="line"><span>            cur = temp;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return pre;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2、删除链表的倒数第-n-个结点-题号-19" tabindex="-1"><a class="header-anchor" href="#_2、删除链表的倒数第-n-个结点-题号-19"><span>2、删除链表的倒数第 N 个结点（题号：19）</span></a></h4><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520165200825.png" alt="image-20250520165200825"></p><p>​ 这道题是双指针法的经典应用，如果要删除倒数第 n 个节点，则让 fast 指针先移动 n 步，然后让 fast 和 slow 指针同时移动弄，知道 fast 指向链表末尾，删除 slow 所指向的节点就可以了。</p><h5 id="具体的实现步骤如下" tabindex="-1"><a class="header-anchor" href="#具体的实现步骤如下"><span>具体的实现步骤如下：</span></a></h5><ol><li>推荐使用虚拟头节点，这样方便处理删除实际头节点的逻辑。</li><li>定义 fast 和 slow 指针，初始值为虚拟头节点（dummyHead），删除倒数第 n 个节点。假设 n 为 2。</li></ol><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520170637161.png" alt="image-20250520170637161"></p><ol start="3"><li>fast 先移动 n+1 步，原因是只有这样，fast 和 slow 同时移动的时候 slow 才能指向删除节点的上一个节点（方便做删除操作）。</li><li>fast 和 slow 同时移动，直到 fast 指向末尾。</li><li>删除 slow 指向的下一个节点，如下图所示：</li></ol><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520171742466.png" alt="image-20250520171742466"></p><h6 id="java-代码如下-4" tabindex="-1"><a class="header-anchor" href="#java-代码如下-4"><span>java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span> public class ListNode {</span></span>
<span class="line"><span>     int val;</span></span>
<span class="line"><span>     ListNode next;</span></span>
<span class="line"><span>     ListNode() {}</span></span>
<span class="line"><span>     ListNode(int val) { this.val = val; }</span></span>
<span class="line"><span>     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Solution {</span></span>
<span class="line"><span>    public ListNode removeNthFromEnd(ListNode head, int n) {</span></span>
<span class="line"><span>        ListNode dummyHead = new ListNode();</span></span>
<span class="line"><span>        dummyHead.next = head;</span></span>
<span class="line"><span>        ListNode fast = dummyHead;</span></span>
<span class="line"><span>        ListNode slow = dummyHead;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (n-- &gt; 0 &amp;&amp; fast != null) {</span></span>
<span class="line"><span>            fast = fast.next;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        fast = fast.next;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (fast != null) {</span></span>
<span class="line"><span>            fast = fast.next;</span></span>
<span class="line"><span>            slow = slow.next;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        slow.next = slow.next.next;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>		return dummyHead.next;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3、环形链表" tabindex="-1"><a class="header-anchor" href="#_3、环形链表"><span>3、环形链表</span></a></h4><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520174026998.png" alt="image-20250520174026998"></p><ol><li><h5 id="判断链表是否有环" tabindex="-1"><a class="header-anchor" href="#判断链表是否有环"><span>判断链表是否有环</span></a></h5><p>​ 定义一个快指针 fast 和一个慢指针 slow，初始都指向头节点。fast 每次移动两个节点，slow 每次移动一个节点，如果 fast 和 slow 在途中相遇，则说明链表有环。</p><p>​ 为什么有环一定会相遇呢？</p><p>​ 原因：如果有环，fast 指针会首先进入环，之后 slow 指针才会进入环，后面的过程可以看成是 fast 指针追赶 slow 指针的过程，因为 fast 每次移动两步，slow 指针每次移动一步，fast 指针是一步一步接近 slow 指针的，所以只要时间足够，fast 指针总是能够追上 slow 指针而且不会错开。</p></li><li><h5 id="寻找环的入口" tabindex="-1"><a class="header-anchor" href="#寻找环的入口"><span>寻找环的入口</span></a></h5><p>​ 假设从头节点到环的入口节点的节点数为 x，环的入口节点到 fast 指针与 slow 指针相遇节点的节点数为 y，从相遇节点再到环的入口节点的节点数为 z，如下图所示。</p></li></ol><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520175416461.png" alt="image-20250520175416461"></p><p>​ 当 fast 指针与 slow 指针相遇时，slow 指针移动的节点数为 x+y，fast 移动的节点数为 x+y+n(y+z),n 的含义为 fast 指针在环内移动了 n 圈才遇到 slow 指针，y+z 为一圈内节点的个数。</p><p>​ 因为 fast 指针是一步移动两个节点，slow 指针是一步移动一个节点，所以 fast 指针移动的节点数=slow 指针移动的节点数 x 2，即</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x+y)*2 = x+y+n(y+z) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p><p>​ 两边消掉一个（x+y），得到</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x+y = n(y+z) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p><p>​ 因为要找环的入口，所以要计算的是 x。因为 x 表示头节点到环的入口节点的距离，所以将 x 单独放在左边：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo>=</mo><mo>&gt;</mo><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x = n(y+z)-y=&gt;x=(n-1)(y+z)+z </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></span></p><p>​ 注意这里 n 一定是大于等于 1 的，因为 fast 指针至少要多移动一圈才能遇到 slow 指针。</p><p>​ 这个公式说明了什么？</p><p>​ 先以 n 为 1 的情况为例，fast 指针在环内移动了一圈之后，就遇到了 slow 指针了，当 n 为 1 的时候，公式就化为：x=z。</p><p>这就意味着，一个指针从头节点出发，另一个指针从相遇节点出发，每次都只移动一个节点，那么两个指针相遇的节点就是环的入口节点。</p><p>​ 如果 n 大于 1 时，相当于 fast 指针多移动了 n-1 圈，然后遇到 slow 指针，上面的方法同样适用，因为环里的指针始终是在环里移动的，可在上图中将 n 代入任意一个数字，模拟一下 n 为 1 时候的情况理解一下。</p><h6 id="java-代码如下-5" tabindex="-1"><a class="header-anchor" href="#java-代码如下-5"><span>java 代码如下：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span> class ListNode {</span></span>
<span class="line"><span>     int val;</span></span>
<span class="line"><span>     ListNode next;</span></span>
<span class="line"><span>     ListNode(int x) {</span></span>
<span class="line"><span>         val = x;</span></span>
<span class="line"><span>         next = null;</span></span>
<span class="line"><span>     }</span></span>
<span class="line"><span> }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class Solution {</span></span>
<span class="line"><span>    public ListNode detectCycle(ListNode head) {</span></span>
<span class="line"><span>        ListNode fast = head;</span></span>
<span class="line"><span>        ListNode slow = head;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while (fast != null &amp;&amp; fast.next != null) {</span></span>
<span class="line"><span>            slow = slow.next;</span></span>
<span class="line"><span>            fast = fast.next.next;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if (fast == slow) {</span></span>
<span class="line"><span>                ListNode index1 = head;</span></span>
<span class="line"><span>                ListNode index2 = fast;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                while (index1 != index2) {</span></span>
<span class="line"><span>                    index1 = index1.next;</span></span>
<span class="line"><span>                    index2 = index2.next;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                return index2;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="额外说明" tabindex="-1"><a class="header-anchor" href="#额外说明"><span>额外说明：</span></a></h5><p>​ 在推理过程中，为什么两个指针第一次在环内相遇，slow 指针移动的部署是 x+y，而不是 x + 若干环的长度 + y 呢？</p><p>​ 假设一种很极端情况：当 slow 指针刚进入环时，fast 指针已经移动一圈了，也位于入口位置（假设这次不算相遇），那么这种情况下，可以看做 fast 在追赶 slow，当 slow 再次移动到环的入口处时，必定与 fast 相遇，因为 slow 移动一圈，fast 会移动两圈。而这种极端情况实际是相遇的情况。除此之外的情况都是 fast 已经在环内了，不是从入口处开始追赶 slow，而是已经移动了几步，所以肯定会在环内追上 slow。</p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520195209169.png" alt="image-20250520195209169"></p><p><img src="https://raw.githubusercontent.com/w123wz/imageck/main/image-20250520195253124.png" alt="image-20250520195253124"></p>`,80)]))}const m=a(l,[["render",p]]),r=JSON.parse('{"path":"/article/rblk6oys/","title":"数组与链表中的双指针法","lang":"zh-CN","frontmatter":{"title":"数组与链表中的双指针法","tags":["王自凯"],"createTime":"2025/05/24 15:47:30","permalink":"/article/rblk6oys/"},"readingTime":{"minutes":9.17,"words":2752},"git":{"updatedTime":1748074806000,"contributors":[{"name":"王自凯","username":"","email":"3509213312@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/04d5b6f1c447019a98f537eb64c61563ec6de010635a022d65ba99bbc81dd161?d=retro"}]},"filePathRelative":"后端/数组与链表中的双指针法.md","headers":[],"categoryList":[{"id":"e778d6","sort":10002,"name":"后端"}]}');export{m as comp,r as data};
