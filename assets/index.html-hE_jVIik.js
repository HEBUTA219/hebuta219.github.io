import{_ as t,c as a,b as p,o as n}from"./app-BrZHaSrv.js";const i={};function r(s,e){return n(),a("div",null,e[0]||(e[0]=[p('<p>锁是保障数据安全的一种机制，把并发的运行变成同一时间只有一个运行，牺牲效率但是保障数据安全。</p><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094204387.png" alt="image-20250510094204387" style="zoom:67%;"><h3 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁"><span>乐观锁和悲观锁</span></a></h3><p><strong>（1）乐观锁</strong></p><p>乐观锁默认数据不会冲突，在数据处理过程中不加锁，只有在提交数据更新的时候校验数据是否一致，本质来说不是锁而是用户自己定义的一种机制。实现方式一般为添加版本号和时间戳字段。</p><p><strong>（2）悲观锁</strong></p><p>悲观锁默认数据会发生冲突，在数据处理过程中对资源加锁，通常用数据库自带的锁机制实现。</p><h3 id="行锁和表锁" tabindex="-1"><a class="header-anchor" href="#行锁和表锁"><span>行锁和表锁</span></a></h3><p><strong>（1）行锁</strong></p><p>特点：开销大，并发度高，锁定粒度小，会出现死锁</p><p>支持引擎：InnoDB</p><p>行锁可以添加共享锁（S）和排他锁（X）（注：不是说共享锁和排他锁属于行锁）</p><p>共享锁：select * from table_name where ... lock in share mode ，主要是为了保证所有的数据读一致</p><p>排他锁：select * from table_name where ... for update，读的时候加X可以解决脏读问题</p><p>一行可以有多个共享锁，但是只能有一个排他锁。</p><p>数据库写行为：insert，delete，update；读行为：select。写行为会自动添加排他锁。读行为默认不加锁，需要手动添加。事务提交（commit）或者回滚（roll back）后解锁（报错也会解锁）。</p><p>事务对数据加了共享锁之后，其他事务只能添加共享锁（能读不能写）。</p><p>事务A、B对同一个数据添加共享锁后，AB事务都不能再对数据进行写操作，如果此时两个事务都要进行写操作，会造成死锁。可以使用更新锁解决这个问题。</p><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094229859.png" alt="image-20250510094229859" style="zoom:80%;"><p>更新锁</p><p>将更新操作分为两步：先读记录，后写记录。</p><p>事务执行更新操作时，先添加更新锁，当事务读数据完毕要执行写操作时，更新锁升级为独占锁。</p><p>同一个资源可以同时放置共享锁和更新锁，但是最多只有一把更新锁。</p><p>事务对数据添加了排他锁后，其他事务不能再加其他锁，加锁的事务可以读写，其他事务能读不能写（加锁的事务未提交的话，其他事务读到的是旧数据）</p><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094259452.png" alt="image-20250510094259452" style="zoom:67%;"><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094314253.png" alt="image-20250510094314253" style="zoom:67%;"><p><strong>（2）表锁</strong></p><p>特点：开销小，并发度低，锁定粒度大，不会出现死锁</p><p>支持引擎：MyISAM，MEMORY，InNoDB</p><p>表锁锁写：lock table table_name write，加锁的事务可以读写，其他事务不能读写。unlock tables解锁</p><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094330552.png" alt="image-20250510094330552" style="zoom:67%;"><p>表锁锁读：lock table table_name read，所有事务都在只能读不能写。</p><img src="https://raw.githubusercontent.com/li1013/A219/main/image-20250510094350264.png" alt="image-20250510094350264" style="zoom:67%;"><h3 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充</span></a></h3><p>InnoDB引擎执行更新操作，在使用主键或者索引时锁行，如果更新语句没有使用索引则会进行全表扫描，此时会锁表或者锁多个行。不</p><p>MyISAM引擎默认锁表。</p><h3 id="待完善" tabindex="-1"><a class="header-anchor" href="#待完善"><span>待完善</span></a></h3><p>同隔离级别下update的行锁不一样，行锁分为记录锁、临间锁、间隙锁，读提交隔离级别下只有记录锁，重复读隔离级别下才有其他两个。</p><p>幻读问题：假设表id有1、3、5、7行，锁id&lt;7的行的时候，其他事务可以添加id=6的行。间隙锁可以锁住id=123456的行</p><p>意向锁</p>',40)]))}const m=t(i,[["render",r]]),l=JSON.parse('{"path":"/article/duvp1dzo/","title":"数据库锁机制","lang":"zh-CN","frontmatter":{"title":"数据库锁机制","tags":["李新月"],"createTime":"2025/05/24 08:20:33","permalink":"/article/duvp1dzo/"},"readingTime":{"minutes":3.15,"words":945},"git":{"updatedTime":1746841967000,"contributors":[{"name":"lixinyue","username":"lixinyue","email":"598187275@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/lixinyue?v=4","url":"https://github.com/lixinyue"}]},"filePathRelative":"后端/数据库锁机制.md","headers":[],"categoryList":[{"id":"e778d6","sort":10002,"name":"后端"}]}');export{m as comp,l as data};
